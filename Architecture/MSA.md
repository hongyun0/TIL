https://youtu.be/mJMzV6GCmPw

## Monolithic

하나의 공통코드(ex. share.jar)와 각각의 서비스들이 나누어져 있다.

공통코드에 전부 코드를 때려넣게 됨. 복잡도와 중복이 엄청나다.

배포가 어렵다.


## MSA

독립된 서비스 -> 조합 -> 기능 제공   

### 제프 베조스의 원칙

1. 이 시간 이후 모든 팀은 자기 팀의 데이터와 기능을 서비스 인터페이스를 통해 오픈한다.
2. 팀은 이 서비스 인터페이스를 통해서만 커뮤니케이션 해야한다.
3. 직접 연결한다든지, 다른 팀의 스토리지에 직접 연동한다든지, 공유 메모리나 백도어를 이용한다든지 등의 다른 커뮤니케이션은 허용되지 않는다. 오직 네트워크를 통한 서비스 인터페이스 호출만이 가능하다.
4. HTTP, Corba, Pubsub, 기존 프로토콜 등 어떤 기술을 쓰든 상관없다.
5. 모든 서비스 인터페이스는 예외 없이 외부에서도 이용할 수 있게 만들어져야 한다. 즉 각 팀은 외부 개발자들이 인터페이스를 이용할 수 있게 서비스 인터페이스를 계획하고 설계해야 한다. 이 지침에 에외는 없다.
6. 이를 시행하지 않는 사람은 누구든 해고다.   

참고 [왓츠 더 퓨쳐](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&barcode=9791162334300)


### 벗어나고팠던 Monolithic의 단점

scale-up으로만 성능 개선이 가능 => scale-out

SPOF(Single points of failure) : 단 하나의 에러만으로도 전체 시스템에 문제가 생길 수 있다.


### MSA를 구성하는 방법

기능 중심으로 구성 (프론트, 추천, 정산, 상품 등)

마이크로서비스 하나의 개발팀은 3~9명

=> 안좋은 예) 9명의 개발자가 12개의 마이크로서비스를 운영하려다가 각 시스템이 잘 살아있나 확인하기 버거워져서 망함.

### MSA의 특징

어느 정도 코드의 중복을 허용 - ex. DTO

마이크로서비스끼리 각자의 Spec에 대한 소통이 필요하다.



